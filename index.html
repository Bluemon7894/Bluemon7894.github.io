<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>재활 자세 데모 (MoveNet + 다중 동작 + 단일 인원 체크)</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#0f1115; color:#eaeff4; font-family:system-ui, sans-serif }
  header { padding:12px 16px; background:#1a1f29; position:sticky; top:0; z-index:2; box-shadow:0 2px 8px rgba(0,0,0,.3) }
  .row { display:flex; gap:16px; padding:16px; flex-wrap:wrap }
  .panel { background:#151922; border:1px solid #232a36; border-radius:14px; padding:12px; }
  #video { display:none; }
  #canvas{ width:720px; height:405px; background:#000; border-radius:12px; }
  .badge { display:inline-block; padding:4px 10px; border-radius:999px; font-weight:600; }
  .ok { background:#103b22; color:#66f5a3; border:1px solid #1f8f56 }
  .bad { background:#3b1020; color:#f5668f; border:1px solid #8f1f4a }
  kbd { background:#222b3a; border:1px solid #33445e; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
  small { color:#9fb0c3 }
  ul { margin:8px 0 0 18px }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:13px }
</style>
</head>
<body>
  <header>
    <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap">
      <div class="badge" style="background:#243147; color:#9ecbff; border:1px solid #3d5a89">MoveNet (TF.js)</div>
      <div id="status" class="badge">초기화 중…</div>
      <div style="flex:1"></div>
      <div>
        <small>
          단축키: <kbd>G</kbd> 좋은 샘플 · <kbd>B</kbd> 나쁜 샘플 · <kbd>R</kbd> 초기화 ·
          <kbd>1</kbd> 스쿼트 · <kbd>2</kbd> 런지 · <kbd>3</kbd> 무릎신전 · <kbd>4</kbd> 팔올리기 · <kbd>E</kbd> 전환
        </small>
      </div>
    </div>
  </header>

  <div class="row">
    <div class="panel">
      <video id="video" playsinline muted></video>
      <canvas id="canvas" width="720" height="405"></canvas>
    </div>

    <div class="panel" style="min-width:320px">
      <h3 style="margin:6px 0 8px">데모 설명</h3>
      <small>
        카메라 → <b>MoveNet</b>(MultiPose) 17 키포인트 → <b>관절각 특징(무릎·고관절·상체)</b> →<br/>
        <b>운동별</b> 샘플(좋음/나쁨)과 유사도 비교 → 실시간 피드백.
      </small>
      <h4 style="margin:12px 0 6px">진행</h4>
      <ul>
        <li><b>한 명만</b> 프레임에 나오게 합니다(여럿 감지 시 판정 보류).</li>
        <li>운동 선택(1~4 또는 E 전환) → <kbd>G</kbd>/<kbd>B</kbd>로 샘플 5~10장씩 저장.</li>
      </ul>
      <div class="mono" id="debug"></div>
    </div>
  </div>

  <!-- TF.js & Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <script>
  // ====== 설정 ======
  const MODEL = poseDetection.SupportedModels.MoveNet;
  const DETECTOR_CONFIG = { modelType: 'MultiPose.Lightning' }; // 여러 명 감지
  const ESTIMATE_OPTS   = { flipHorizontal: false, maxPoses: 5, scoreThreshold: 0.3, nmsRadius: 20 };

  const CONF_THR = 0.15;   // 키포인트 신뢰도 임계
  const MAX_SAMPLES = 200; // 로컬 샘플 최대
  const THR_GOOD = 8.0;    // GOOD 임계(도)
  const MARGIN   = 2.0;    // GOOD이 BAD보다 이만큼 더 가까워야 GOOD

  // 운동 프리셋
  const EX_LIST = ['squat','lunge','kneeext','armraise'];
  let EX_IDX = 0; // 현재 운동 인덱스
  const EX_NAME = {
    squat:'스쿼트', lunge:'런지', kneeext:'무릎 신전', armraise:'팔 올리기'
  };

  // ====== 유틸 ======
  const KP = { NOSE:0, L_EYE:1, R_EYE:2, L_EAR:3, R_EAR:4, L_SHO:5, R_SHO:6, L_ELB:7, R_ELB:8, L_WR:9, R_WR:10, L_HIP:11, R_HIP:12, L_KNEE:13, R_KNEE:14, L_ANK:15, R_ANK:16 };
  function degAngle(a,b,c){ if(!a||!b||!c) return null; const v1=[a.x-b.x,a.y-b.y], v2=[c.x-b.x,c.y-b.y]; const n1=Math.hypot(...v1), n2=Math.hypot(...v2); if(!n1||!n2) return null; let cos=(v1[0]*v2[0]+v1[1]*v2[1])/(n1*n2); cos=Math.max(-1,Math.min(1,cos)); return Math.acos(cos)*180/Math.PI; }
  function torsoIncline(shoulder, hip){ if(!shoulder||!hip) return null; const vx=hip.x-shoulder.x, vy=hip.y-shoulder.y, n=Math.hypot(vx,vy); if(!n) return null; let cos=(0*vx+1*vy)/n; cos=Math.max(-1,Math.min(1,cos)); return Math.acos(cos)*180/Math.PI; }
  function sel(kps, i){ const p=kps[i]; const s=p?.score ?? p?.confidence ?? 0; if(s<CONF_THR) return null; return {x:p.x,y:p.y}; }

  // 공통 특징(5차원) — 운동이 달라도 샘플만 다르게 저장/비교
  function extractFeatures(kps){
    const LE=sel(kps,KP.L_SHO), RE=sel(kps,KP.R_SHO);
    const LH=sel(kps,KP.L_HIP), RH=sel(kps,KP.R_HIP);
    const LK=sel(kps,KP.L_KNEE), RK=sel(kps,KP.R_KNEE);
    const LA=sel(kps,KP.L_ANK),  RA=sel(kps,KP.R_ANK);
    const l_knee=degAngle(LH,LK,LA), r_knee=degAngle(RH,RK,RA);
    const l_hip =degAngle(LE,LH,LK), r_hip =degAngle(RE,RH,RK);
    const tL=torsoIncline(LE,LH), tR=torsoIncline(RE,RH); const torso=(tL!=null&&tR!=null)?(tL+tR)/2:(tL??tR);
    const feats=[l_knee,r_knee,l_hip,r_hip,torso];
    if(feats.some(v=>v==null)) return null;
    return feats.map(v=>Math.max(0,Math.min(180,v)));
  }

  const MAE=(a,b)=>a.reduce((s,v,i)=>s+Math.abs(v-b[i]),0)/a.length;

  // ====== 로컬 스토리지(운동별로 분리) ======
  function keyFor(ex){ return `rehab_samples_${ex}_v1`; }
  function loadSamples(ex){ try{const o=JSON.parse(localStorage.getItem(keyFor(ex))||'{}'); return {good:o.good||[],bad:o.bad||[]};}catch{return{good:[],bad:[]}} }
  function saveSamples(ex,s){ localStorage.setItem(keyFor(ex), JSON.stringify(s)); }
  function addSample(ex, type, feat){ const s=loadSamples(ex); s[type]=[...s[type],feat].slice(-MAX_SAMPLES); saveSamples(ex,s); }
  function clearSamples(ex){ saveSamples(ex,{good:[],bad:[]}); }

  // ====== 요소 ======
  const video = document.getElementById('video');
  const canvas= document.getElementById('canvas');
  const ctx   = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const debugEl  = document.getElementById('debug');
  let detector;

  async function setupCam(){
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user',width:1280,height:720},audio:false});
    video.srcObject=stream; await video.play();
    const W=720,H=Math.round(W*9/16); canvas.width=W; canvas.height=H;
    window._vW=video.videoWidth; window._vH=video.videoHeight;
  }

  function drawSkeleton(kps){
    const E=[[KP.L_SHO,KP.R_SHO],[KP.L_SHO,KP.L_ELB],[KP.L_ELB,KP.L_WR],[KP.R_SHO,KP.R_ELB],[KP.R_ELB,KP.R_WR],[KP.L_SHO,KP.L_HIP],[KP.R_SHO,KP.R_HIP],[KP.L_HIP,KP.R_HIP],[KP.L_HIP,KP.L_KNEE],[KP.L_KNEE,KP.L_ANK],[KP.R_HIP,KP.R_KNEE],[KP.R_KNEE,KP.R_ANK]];
    ctx.lineWidth=3; ctx.strokeStyle='#6fb4ff';
    E.forEach(([a,b])=>{ const pa=kps[a], pb=kps[b]; if(pa&&pb&&(pa.score??0)>CONF_THR&&(pb.score??0)>CONF_THR){ ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.stroke(); }});
    kps.forEach(p=>{ if(p&&(p.score??0)>CONF_THR){ ctx.beginPath(); ctx.fillStyle='#ffd166'; ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }});
  }

  function judge(ex, feat){
    const s=loadSamples(ex);
    const dG=s.good.length?Math.min(...s.good.map(g=>MAE(feat,g))):1e9;
    const dB=s.bad.length ?Math.min(...s.bad.map(b=>MAE(feat,b))) :1e9;
    if(s.good.length===0&&s.bad.length===0) return {text:`샘플을 먼저 저장하세요 (G/B) – ${EX_NAME[ex]}`, color:'#9ecbff', dG, dB};
    if(dG<=THR_GOOD && dG+MARGIN<dB) return {text:`올바른 자세입니다! 계속하세요! – ${EX_NAME[ex]}`, color:'#66f5a3', dG, dB};
    return {text:`틀린 자세입니다. 자세를 바꿔주세요! – ${EX_NAME[ex]}`, color:'#f5668f', dG, dB};
  }

  function scaleKeypoints(kps){
    const vW=window._vW||video.videoWidth||canvas.width, vH=window._vH||video.videoHeight||canvas.height;
    const sx=canvas.width/vW, sy=canvas.height/vH;
    return kps.map(k=>({ x:k.x*sx, y:k.y*sy, score:k.score??k.confidence??0 }));
  }

  function exercise(){ return EX_LIST[EX_IDX]; }
  function cycleExercise(){ EX_IDX=(EX_IDX+1)%EX_LIST.length; }

  async function loop(){
    // 비디오 프레임 그림
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // 다중 포즈 추정
    const poses = await detector.estimatePoses(video, ESTIMATE_OPTS);

    if (!poses || poses.length === 0) {
      statusEl.className='badge'; statusEl.textContent='사람을 찾지 못했습니다.'; debugEl.textContent='';
      return requestAnimationFrame(loop);
    }
    if (poses.length > 1) {
      // 여러 명일 때: 안내하고 판정 보류
      statusEl.className='badge'; statusEl.textContent='사람이 여러명 있습니다. 화면에 한 명만 나오게 해주세요.'; debugEl.textContent='';
      // 가장 신뢰 높은 1명만 윤곽 표시(선택 도움)
      const main = poses.sort((a,b)=>(b.score||0)-(a.score||0))[0];
      drawSkeleton(scaleKeypoints(main.keypoints));
      return requestAnimationFrame(loop);
    }

    // 단 한 명일 때만 판정
    const kpsScaled = scaleKeypoints(poses[0].keypoints);
    drawSkeleton(kpsScaled);

    const feat=extractFeatures(kpsScaled);
    if(feat){
      const ex = exercise();
      const v=judge(ex, feat);
      statusEl.className='badge ' + (v.color==='#66f5a3'?'ok': v.color==='#9ecbff'?'':'bad');
      statusEl.style.borderColor=v.color; statusEl.style.color=v.color; statusEl.textContent=v.text;
      const s=loadSamples(ex);
      debugEl.textContent=`운동: ${EX_NAME[ex]} | 샘플 good:${s.good.length} bad:${s.bad.length} | d_good:${v.dG.toFixed(1)} d_bad:${v.dB.toFixed(1)} | feat=${feat.map(x=>x.toFixed(0)).join(', ')}`;
    }else{
      statusEl.className='badge'; statusEl.textContent='관절 신뢰도가 낮습니다. 전신이 보이게 서 주세요.'; debugEl.textContent='';
    }
    requestAnimationFrame(loop);
  }

  // 단축키
  window.addEventListener('keydown', e=>{
    const ex = exercise();
    if(e.key==='g'||e.key==='G'){
      detector.estimatePoses(video,ESTIMATE_OPTS).then(ps=>{
        if(ps&&ps.length===1){
          const feat=extractFeatures(scaleKeypoints(ps[0].keypoints));
          if(feat){ addSample(ex,'good',feat); statusEl.textContent=`좋은 샘플 저장 – ${EX_NAME[ex]}`; }
        }
      });
    }
    if(e.key==='b'||e.key==='B'){
      detector.estimatePoses(video,ESTIMATE_OPTS).then(ps=>{
        if(ps&&ps.length===1){
          const feat=extractFeatures(scaleKeypoints(ps[0].keypoints));
          if(feat){ addSample(ex,'bad',feat); statusEl.textContent=`나쁜 샘플 저장 – ${EX_NAME[ex]}`; }
        }
      });
    }
    if(e.key==='r'||e.key==='R'){ clearSamples(ex); statusEl.textContent=`샘플 초기화 완료 – ${EX_NAME[ex]}`; }
    if(e.key==='e'||e.key==='E'){ cycleExercise(); statusEl.textContent=`운동 전환: ${EX_NAME[exercise()]}`; }
    if(e.key==='1'){ EX_IDX=0; statusEl.textContent=`운동 전환: ${EX_NAME[exercise()]}`; }
    if(e.key==='2'){ EX_IDX=1; statusEl.textContent=`운동 전환: ${EX_NAME[exercise()]}`; }
    if(e.key==='3'){ EX_IDX=2; statusEl.textContent=`운동 전환: ${EX_NAME[exercise()]}`; }
    if(e.key==='4'){ EX_IDX=3; statusEl.textContent=`운동 전환: ${EX_NAME[exercise()]}`; }
  });

  (async()=>{
    try{
      await setupCam();
      detector = await poseDetection.createDetector(MODEL, DETECTOR_CONFIG);
      statusEl.textContent=`카메라 준비 완료 – 현재 운동: ${EX_NAME[exercise()]}`;
      loop();
    }catch(err){
      statusEl.textContent='초기화 실패: '+err.message; console.error(err);
    }
  })();
  </script>
</body>
</html>
